Variables
name="John"
echo $name  
echo "$name"
echo "${name}!"

Shell execution
echo "I'm in $(pwd)"

Conditional execution
git commit && git push
git commit || echo "Commit failed"

Functions
get_name() {
  echo "John"
}
echo "You are $(get_name)"

if [[ -z "$string" ]]; then
  echo "String is empty"
elif [[ -n "$string" ]]; then
  echo "String is not empty"
fi

Brace expansion
echo {A,B}.js
{A,B}	          Same as A B
{A,B}.js	      Same as A.js B.js
{1..5}	          Same as 1 2 3 4 5
{{1..3},{7..9}}	  Same as 1 2 3 7 8 9

name="John"
echo "${name}"
echo "${name/J/j}"         #=> "john" (substitution)
echo "${name:0:2}"         #=> "Jo" (slicing)
echo "${name::2}"          #=> "Jo" (slicing)
echo "${name::-1}"         #=> "Joh" (slicing)
echo "${name:(-1)}"        #=> "n" (slicing from right)
echo "${name:(-2):1}"      #=> "h" (slicing from right)
echo "${food:-Cake}"       #=> $food or "Cake"
length=2
echo "${name:0:length}"    #=> "Jo"
See: Parameter expansion

str="/path/to/foo.cpp"
echo "${str%.cpp}"         # /path/to/foo
echo "${str%.cpp}.o"       # /path/to/foo.o
echo "${str%/*}"           # /path/to
echo "${str##*.}"          # cpp (extension)
echo "${str##*/}"          # foo.cpp (basepath)
echo "${str#*/}"           # path/to/foo.cpp
echo "${str##*/}"          # foo.cpp
echo "${str/foo/bar}"      # /path/to/bar.cpp

str="Hello world"
echo "${str:6:5}"          # "world"
echo "${str: -5:5}"        # "world"

src="/path/to/foo.cpp"
base=${src##*/}            #=> "foo.cpp" (basepath)
dir=${src%$base}           #=> "/path/to/" (dirpath)
dir=${src%/*}              #=> "/path/to" (dirpath)

Substitution
${foo%suffix}              Remove suffix
${foo#prefix}              Remove prefix
${foo%%suffix}             Remove long suffix
${foo/%suffix}             Remove long suffix
${foo##prefix}             Remove long prefix
${foo/#prefix}             Remove long prefix
${foo/from/to}             Replace first match
${foo//from/to}            Replace all
${foo/%from/to}            Replace suffix
${foo/#from/to}            Replace prefix

Substrings
${foo:0:3}                 Substring (position, length)
${foo:(-3):3}              Substring from the right
Length
${#foo}                    Length of $foo

Manipulation
str="HELLO WORLD!"
echo "${str,}"             #=> "hELLO WORLD!" (lowercase 1st letter)
echo "${str,,}"            #=> "hello world!" (all lowercase)

str="hello world!"
echo "${str^}"             #=> "Hello world!" (uppercase 1st letter)
echo "${str^^}"            #=> "HELLO WORLD!" (all uppercase)

Basic for loop
for i in /etc/rc.*; do
  echo "$i"
done

C-like for loop
for ((i = 0 ; i < 100 ; i++)); do
  echo "$i"
done

Ranges
for i in {1..5}; do
    echo "Welcome $i"
done

With step size
for i in {5..50..5}; do
    echo "Welcome $i"
done

Reading lines
while read -r line; do
  echo "$line"
done <file.txt

Forever
while true; do
  ···
done

Conditions
[[ -z STRING ]]         Empty string
[[ -n STRING ]]         Not empty string
[[ STRING == STRING ]]	Equal
[[ STRING != STRING ]]	Not Equal
[[ NUM -eq NUM ]]       Equal
[[ NUM -ne NUM ]]       Not equal
[[ NUM -lt NUM ]]       Less than
[[ NUM -le NUM ]]       Less than or equal
[[ NUM -gt NUM ]]       Greater than
[[ NUM -ge NUM ]]       Greater than or equal
[[ STRING =~ STRING ]]	Regexp
(( NUM < NUM ))	Numeric conditions

More conditions
[[ -o noclobber ]]	If OPTIONNAME is enabled
[[ ! EXPR ]]        Not
[[ X && Y ]]        And
[[ X || Y ]]        Or

File conditions
[[ -e FILE ]]           Exists
[[ -r FILE ]]           Readable
[[ -h FILE ]]           Symlink
[[ -d FILE ]]           Directory
[[ -w FILE ]]           Writable
[[ -s FILE ]]           Size is > 0 bytes
[[ -f FILE ]]           File
[[ -x FILE ]]           Executable
[[ FILE1 -nt FILE2 ]]	1 is more recent than 2
[[ FILE1 -ot FILE2 ]]	2 is more recent than 1
[[ FILE1 -ef FILE2 ]]	Same files

Numeric calculations
$((a + 200))            # Add 200 to $a
$(($RANDOM%200))        # Random number 0..199
declare -i count        # Declare as type integer
count+=1                # Increment

Subshells
(cd somedir; echo "I'm now in $PWD")
pwd # still in first directory

Redirection
python hello.py > output.txt            # stdout to (file)
python hello.py >> output.txt           # stdout to (file), append
python hello.py 2> error.log            # stderr to (file)
python hello.py 2>&1                    # stderr to stdout
python hello.py 2>/dev/null             # stderr to (null)
python hello.py >output.txt 2>&1        # stdout and stderr to (file), equivalent to &>
python hello.py &>/dev/null             # stdout and stderr to (null)
echo "$0: warning: too many users" >&2  # print diagnostic message to stderr
python hello.py < foo.txt               # feed foo.txt to stdin for python
diff <(ls -r) <(ls)                     # Compare two stdout without files